// TODO change Model gem name, add callback to BatleLogic
var Model = exports.Model =
{
	EMPTY_PIECE_ID			: 0,
	RED_PIECE_ID			: 1,
	GREEN_PIECE_ID			: 2,
	YELLOW_PIECE_ID			: 3,
	PURPLE_PIECE_ID			: 4,
	ORANGE_PIECE_ID			: 5,

	UPPER_NORMAL_PIECE_ID	: 10,

	// these balls will explode nearby balls
	SP1_RED_PIECE_ID		: 11,
	SP1_GREEN_PIECE_ID		: 12,
	SP1_YELLOW_PIECE_ID		: 13,
	SP1_PURPLE_PIECE_ID		: 14,
	SP1_ORANGE_PIECE_ID		: 15,

	UPPER_SP1_PIECE_ID		: 20,

	// these balls will explode all ball in straight lines
	SP2_RED_PIECE_ID		: 21,
	SP2_GREEN_PIECE_ID		: 22,
	SP2_YELLOW_PIECE_ID		: 23,
	SP2_PURPLE_PIECE_ID		: 24,
	SP2_ORANGE_PIECE_ID		: 25,

	// // skill list
	// public static final byte SKILL_LINE_PIECE_ID : 18,
	// public static final byte SKILL_RIGH_PIECE_ID : 19,

	// these balls explode all balls in the same color
	SP3_PIECE_ID			: 30,

	// these gems are same as normal gems except they can generate skill
	HD_RED_PIECE_ID			: 31,
	HD_GREEN_PIECE_ID		: 32,
	HD_YELLOW_PIECE_ID		: 33,
	HD_PURPLE_PIECE_ID		: 34,
	HD_ORANGE_PIECE_ID		: 35,

	MAX_TIME				: 30.0
}

var Character = exports.Character =
{
	STATUS_NORMAL : 0,
	STATUS_DIZZY : 1 << 0,
	STATUS_GUARDED : 1 << 1,
	STATUS_REFLECT : 1 << 2,
	DEFAULT_STATUS_DURATION	: 10,
	MINIMUM_STATUS_DURATION	: 0.0001
}

var BattleLogic = exports.BattleLogic =
{
	HP_COMBO_FILL_RATE : 7,
	MP_COMBO_FILL_RATE : 0,
	MP_COST_RATE : 0,

	predictMpCost : function( skillType, power )
	{
		var normalized = BattleCommand.normalizeSkillType( skillType );
		var rank = BattleCommand.getSkillRank( skillType );
		var invokerMpCost = 0;
		switch ( normalized )
		{
			case BattleCommand.COMMAND_ATTACK_1:
			case BattleCommand.COMMAND_ATTACK_2:
			case BattleCommand.COMMAND_ATTACK_3:
				if ( rank == 0 )
				{
					invokerMpCost = power * BattleLogic.MP_COST_RATE;
				}
				break;
			default:
				invokerMpCost = 0;
				break;
		}
		return invokerMpCost;
	}
}

var Command = exports.Command =
{
	// move by player
	COMMAND_INPUT_MOVE				: 0,

	// swap 2 point and swap back
	COMMAND_WRONG_MOVE				: 1,

	// move by logic
	COMMAND_MOVE					: 2,

	// select 1 point
	COMMAND_SELECT					: 3,

	// finish calculate hint
	COMMAND_HINT					: 4,

	// notify game is over
	COMMAND_GAME_OVER				: 5,

	// clear all balls on view
	COMMAND_NEW_GAME				: 6,

	// clear all balls on view to refresh match
	COMMAND_REFRESH					: 7,

	// ready for user input
	COMMAND_READY					: 8,

	// first two params are coordinate of sp gem, param2X is type of gem
	COMMAND_CREATE_SP1_GEM			: 9,

	// first two params are coordinate of sp gem, has gemtype, params2y is the number of gems eaten.
	COMMAND_CREATE_SP2_GEM			: 10,

	// first two params are coordinate of sp gem
	COMMAND_CREATE_SP3_GEM			: 11,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_EAT_GEMS_VERTICAL		: 12,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_EAT_GEMS_HORIZONTAL		: 13,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_EAT_GEMS_RIGHT_ANGLE	: 14,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_ACTIVE_SP1				: 15,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_ACTIVE_SP2				: 16,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_ACTIVE_SP3				: 17,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_ACTIVE_SP_UL			: 18,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_EAT_GEMS_SP_UL			: 19,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_EAT_GEMS_SP1			: 20,

	// first two params are coordinate of gem, second two are interesting point
	COMMAND_EAT_GEMS_SP2			: 21,

	// first two params are coordinate of gem
	COMMAND_EAT_GEMS_MONEY_1		: 22,

	// first two params are coordinate of gem
	COMMAND_EAT_GEMS_MONEY_2		: 23,

	// first two params are coordinate of combo, params2X is number of comboes
	COMMAND_NOTIFY_COMBO			: 24,

	// first two params are coordinate of skill gem, gem type is normalise type of gems
	// params2Y is actually number of gems eaten to create that skill
	COMMAND_CREATE_SKILL_RIGHT		: 25,

	// first two params are coordinate of skill gem, gem type is normalise type of gems
	// params2Y is actually number of gems eaten to create that skill
	COMMAND_CREATE_SKILL_LINE		: 26,

	// this command is used to combine combo to send to battle logic
	// param2Y hold number of gem collected
	COMMAND_COMBINE_GEMS			: 27,

	COMMAND_EAT_GEMS_SP3			: 28,

	isPostActiveSkill : function( skill )
	{
		if ( skill.commandId == Command.COMMAND_CREATE_SKILL_RIGHT )
		{
			return true;
		}
		else
		{
			return false;
		}
	}
}

var BattleCommand = exports.BattleCommand =
{
	PLAYER_ZERO : 0,
	PLAYER_1 : 1,
	PLAYER_2 : 2,

	// no command
	COMMAND_NULL			: -1,

	// basic: 3 4 5 line
	COMMAND_ATTACK_1		: 0,
	COMMAND_ATTACK_2		: 1,
	COMMAND_ATTACK_3		: 2,
	COMMAND_HEAL			: 3,
	COMMAND_ENERGY_UP		: 4,
	COMMAND_MONEY			: 5,

	// One player is finished, use id to show the winner, 0 : draw
	COMMAND_KO				: 6,

	// time is over, end the battle, use id to show the winner, 0 : draw
	COMMAND_TIME_OUT		: 7,
	COMMAND_NEW_GAME		: 8,

	COMMAND_DISCONNECTED	: 9,

	// status, power in the command is status type, see Character class
	COMMAND_STATUS_START	: 16,
	COMMAND_STATUS_END		: 17,

	// special right 5
	COMMAND_ATTACK_1_SP_1	: 10,
	COMMAND_ATTACK_2_SP_1	: 11,
	COMMAND_ATTACK_3_SP_1	: 12,
	COMMAND_HEAL_SP_1		: 13,
	COMMAND_ENERGY_UP_SP_1	: 14,
	COMMAND_MONEY_SP_1		: 15,

	// special right 6
	COMMAND_ATTACK_1_SP_2	: 20,
	COMMAND_ATTACK_2_SP_2	: 21,
	COMMAND_ATTACK_3_SP_2	: 22,
	COMMAND_HEAL_SP_2		: 23,
	COMMAND_ENERGY_UP_SP_2	: 24,
	COMMAND_MONEY_SP_2		: 25,

	// special right 7+
	COMMAND_ATTACK_1_SP_3	: 30,
	COMMAND_ATTACK_2_SP_3	: 31,
	COMMAND_ATTACK_3_SP_3	: 32,
	COMMAND_HEAL_SP_3		: 33,
	COMMAND_ENERGY_UP_SP_3	: 34,
	COMMAND_MONEY_SP_3		: 35,


	getSkillRank : function( skillType )
	{
		if ( skillType > 29 )
		{
			return 3;
		}
		else if ( skillType > 19 )
		{
			return 2;
		}
		else if ( skillType > 9 )
		{
			return 1;
		}
		return 0;
	},

	normalizeSkillType : function( skillType )
	{
		if ( skillType > 29 )
		{
			skillType -= 30;
		}
		else if ( skillType > 19 )
		{
			skillType -= 20;
		}
		else if ( skillType > 9 )
		{
			skillType -= 10;
		}
		return skillType;
	},
	gemsSkillToBattleCommand : function( c )
	{
		if ( c == null )
		{
			return null;
		}

		var bc = createBattleCommand();

		// currently power = number of gems collected, can be modify by skill type
		// cost same "power" mp to use skill
		bc.power = c.param2Y;
		bc.mpCost = bc.power;

		// 2x store player id
		bc.playerId = c.param2X;
		if ( bc.playerId > 2 || bc.playerId < 0 )
		{
			console.log( 'BattleCommand:gemsSkillToBattleCommand: Unknown player ' + bc.playerId );
		}

		// skill type
		switch ( c.gemType )
		{
			case Model.RED_PIECE_ID:
				bc.commandType = BattleCommand.COMMAND_ATTACK_1;
				break;
			case Model.ORANGE_PIECE_ID:
				bc.commandType = BattleCommand.COMMAND_ATTACK_2;
				break;
			case Model.PURPLE_PIECE_ID:
				bc.commandType = BattleCommand.COMMAND_ATTACK_3;
				break;
			// case Model.BLUE_PIECE_ID:
			// bc.commandType = BattleCommand.COMMAND_ENERGY_UP;
			// break;
			case Model.GREEN_PIECE_ID:
				bc.commandType = BattleCommand.COMMAND_HEAL;
				break;
			case Model.YELLOW_PIECE_ID:
			default:
				bc.commandType = BattleCommand.COMMAND_MONEY;
				break;
		}

		// skill
		if ( c.commandId == Command.COMMAND_CREATE_SKILL_RIGHT )
		{
			bc.mpCost = 0;
			if ( bc.power > 6 )
			{
				bc.commandType += 30;
			}
			else if ( bc.power > 5 )
			{
				bc.commandType += 20;
			}
			else
			{
				bc.commandType += 10;
			}
		}

		return bc;
	}
}

var createCommand = exports.createCommand = function()
{
	var createCommandObj = {};
	createCommandObj.commandId = 0;
	createCommandObj.gemType = 0;
	createCommandObj.param1X = 0;
	createCommandObj.param1Y = 0;
	createCommandObj.param2X = 0
	createCommandObj.param2Y = 0;

	createCommandObj.copy = function( other )
	{
		createCommandObj.commandId = other.commandId;
		createCommandObj.gemType = other.gemType;
		createCommandObj.param1X = other.param1X;
		createCommandObj.param1Y = other.param1Y;
		createCommandObj.param2X = other.param2X;
		createCommandObj.param2Y = other.param2Y;
	}

	return createCommandObj;
}

var createCharacter = exports.createCharacter = function()
{
	var createCharacterObj = {};
	createCharacterObj.name = '';
	createCharacterObj.maxHp = 0;
	createCharacterObj.maxMp = 0;
	createCharacterObj.hp = 0;
	createCharacterObj.mp = 0;
	createCharacterObj.lv = 0;
	createCharacterObj.atk1 = 0;
	createCharacterObj.atk2 = 0;
	createCharacterObj.atk3 = 0;
	createCharacterObj.def = 0;
	createCharacterObj.money = 0;
	createCharacterObj.race = 0;
	createCharacterObj.dizzyDuration = 0;
	createCharacterObj.guardedDuration = 0;
	createCharacterObj.reflectDuration = 0;
	createCharacterObj.totalDamageDealt	= 0;
	createCharacterObj.status = Character.STATUS_NORMAL;

	// use to mark last update time stamp, use in process
	createCharacterObj.lastUpdate = -1;

	createCharacterObj.addTotalDamageDealt = function( damage )
	{
		createCharacterObj.totalDamageDealt += damage;
	}

	createCharacterObj.getMaxHp = function( )
	{
		return createCharacterObj.maxHp;
	}

	createCharacterObj.getMaxMp = function( )
	{
		return createCharacterObj.maxMp;
	}

	createCharacterObj.getStatus = function( )
	{
		return createCharacterObj.status;
	}

	createCharacterObj.getTotalDamageDealt = function( )
	{
		return createCharacterObj.totalDamageDealt;
	}

	createCharacterObj.isDizzy = function( )
	{
		return ( createCharacterObj.status & Character.STATUS_DIZZY ) != 0;
	};
	createCharacterObj.isGuarded = function( )
	{
		return ( createCharacterObj.status & Character.STATUS_GUARDED ) != 0;
	};

	createCharacterObj.isNormal = function( )
	{
		return createCharacterObj.status == 0;
	};

	createCharacterObj.isReflect = function( )
	{
		return ( createCharacterObj.status & Character.STATUS_REFLECT ) != 0;
	};

	createCharacterObj.setStatus = function( on, statusCode )
	{
		switch ( statusCode )
		{
			case Character.STATUS_DIZZY:
				createCharacterObj.status = on ? createCharacterObj.status | Character.STATUS_DIZZY : createCharacterObj.status & ~Character.STATUS_DIZZY;
				createCharacterObj.dizzyDuration = Character.DEFAULT_STATUS_DURATION;
				break;
			case Character.STATUS_GUARDED:
				createCharacterObj.status = on ? createCharacterObj.status | Character.STATUS_GUARDED : createCharacterObj.status & ~Character.STATUS_GUARDED;
				createCharacterObj.guardedDuration = Character.DEFAULT_STATUS_DURATION;
				break;
			case Character.STATUS_REFLECT:
				createCharacterObj.status = on ? createCharacterObj.status | Character.STATUS_REFLECT : createCharacterObj.status & ~Character.STATUS_REFLECT;
				createCharacterObj.reflectDuration = Character.DEFAULT_STATUS_DURATION;
				break;
			case Character.STATUS_NORMAL:
				createCharacterObj.status = 0;
				break;
		}
	};

	createCharacterObj.copy = function( character )
	{
		createCharacterObj.maxHp = character.maxHp;
		createCharacterObj.maxMp = character.maxMp;

		createCharacterObj.name = character.name;
		// HP
		createCharacterObj.hp = character.hp;
		// Mana
		createCharacterObj.mp = character.mp;

		createCharacterObj.lv = character.lv;

		createCharacterObj.race = character.race;

		createCharacterObj.atk1 = character.atk1;
		createCharacterObj.atk2 = character.atk2;
		createCharacterObj.atk3 = character.atk3;
		createCharacterObj.def = character.def;
		createCharacterObj.money = character.money;

		createCharacterObj.totalDamageDealt = character.totalDamageDealt;

		createCharacterObj.dizzyDuration = character.dizzyDuration;
		createCharacterObj.guardedDuration = character.guardedDuration;
		createCharacterObj.reflectDuration = character.reflectDuration;

		createCharacterObj.status = character.status;
	};


	createCharacterObj.setMaxHp = function( maxHp )
	{
		createCharacterObj.maxHp = maxHp;
	}

	createCharacterObj.setMaxMp = function( maxMp )
	{
		createCharacterObj.maxMp = maxMp;
	}

	/**
	 * Make sure hp and mp in bound.
	 */
	createCharacterObj.trim = function( )
	{
		if ( createCharacterObj.hp < 0 )
		{
			createCharacterObj.hp = 0;
		}
		else if ( createCharacterObj.hp > createCharacterObj.maxHp )
		{
			createCharacterObj.hp = createCharacterObj.maxHp;
		}

		if ( createCharacterObj.mp < 0 )
		{
			createCharacterObj.mp = 0;
		}
		else if ( createCharacterObj.mp > createCharacterObj.maxMp )
		{
			createCharacterObj.mp = createCharacterObj.maxMp;
		}
	}

	createCharacterObj.charProcess = function( )
	{
		var delta = 0.017;
		if(createCharacterObj.lastUpdate < 0)
		{
			createCharacterObj.lastUpdate = Date.now();
		}
		else
		{
			var timeInMs = Date.now();
			delta = (timeInMs - createCharacterObj.lastUpdate)/1000.0;
			createCharacterObj.lastUpdate = timeInMs;
		}

		if ( createCharacterObj.status == Character.STATUS_NORMAL )
		{
			return;
		}

		if ( createCharacterObj.isDizzy( ) && createCharacterObj.dizzyDuration > Character.MINIMUM_STATUS_DURATION )
		{
			createCharacterObj.dizzyDuration -= delta;

			if ( createCharacterObj.dizzyDuration <= Character.MINIMUM_STATUS_DURATION )
			{
				createCharacterObj.dizzyDuration = 0;
				createCharacterObj.setStatus( false, Character.STATUS_DIZZY );
			}
		}

		if ( createCharacterObj.isGuarded( ) && createCharacterObj.guardedDuration > Character.MINIMUM_STATUS_DURATION )
		{
			createCharacterObj.guardedDuration -= delta;

			if ( createCharacterObj.guardedDuration <= Character.MINIMUM_STATUS_DURATION )
			{
				createCharacterObj.guardedDuration = 0;
				createCharacterObj.setStatus( false, Character.STATUS_GUARDED );
			}
		}

		if ( createCharacterObj.isReflect( ) && createCharacterObj.reflectDuration > Character.MINIMUM_STATUS_DURATION )
		{
			createCharacterObj.reflectDuration -= delta;

			if ( createCharacterObj.reflectDuration <= Character.MINIMUM_STATUS_DURATION )
			{
				createCharacterObj.reflectDuration = 0;
				createCharacterObj.setStatus( false, Character.STATUS_REFLECT );
			}
		}
	};

	return createCharacterObj;
};
/*
 createBattleModel
 */
var createBattleModel = exports.createBattleModel = function()
{
	var createBattleModelObj = {};
	createBattleModelObj.character1 = createCharacter();
	createBattleModelObj.character2 = createCharacter();

	createBattleModelObj.copy = function( other )
	{
        createBattleModelObj.character1.copy( other.character1 );
        createBattleModelObj.character2.copy( other.character2 );
	};

	createBattleModelObj.battleModelProcess = function()
	{
		createBattleModelObj.character1.charProcess();
		createBattleModelObj.character2.charProcess();
	};

	return createBattleModelObj;
};

var createBattleCommand = exports.createBattleCommand = function()
{
	var createBattleCommandObj = {};
	createBattleCommandObj.playerId = 1;
	createBattleCommandObj.commandType = 0;
	createBattleCommandObj.power = 0;
	createBattleCommandObj.mpCost = 0;

	createBattleCommandObj.copy = function( battleCommand )
	{
		createBattleCommandObj.commandType = battleCommand.commandType;
		createBattleCommandObj.playerId = battleCommand.playerId;
		createBattleCommandObj.power = battleCommand.power;
		createBattleCommandObj.mpCost = battleCommand.mpCost;
	};

	return createBattleCommandObj;
};

var createScore = exports.createScore = function()
{
	var createScoreObj = {};
	createScoreObj.totalNumberOfGems			= 0;
	createScoreObj.totalNumberOfCombo			= 0;
	createScoreObj.remainBlood					= 0;
	createScoreObj.timeRemain					= 0;
	createScoreObj.totalNumberOfGoldCollected	= 0;
	createScoreObj.totalNumberOfDamageDealt		= 0;
	createScoreObj.charMaxHp					= 0;
	createScoreObj.smallChessOpened = [];
	createScoreObj.bigChessOpened = [];
	createScoreObj.isWin = false;


	createScoreObj.calculateMedal = function( )
	{
		var medal = 0;
		if ( createScoreObj.timeRemain > 169 )
		{
			return medal;
		}
		if ( createScoreObj.totalNumberOfGems < 11 )
		{
			return medal;
		}
		var gold = createScoreObj.totalNumberOfGoldCollected * 10;
		medal += createScoreObj.totalNumberOfGems >= 300 ? 3 : createScoreObj.totalNumberOfGems >= 200 ? 2 : 1;
		medal += createScoreObj.totalNumberOfCombo >= 100 ? 3 : createScoreObj.totalNumberOfCombo >= 50 ? 2 : createScoreObj.totalNumberOfCombo >= 10 ? 1 : 0;

		if ( createScoreObj.isWin )
		{
			if ( createScoreObj.charMaxHp != 0 )
			{
				var mid = createScoreObj.charMaxHp >> 1;
				var small = createScoreObj.charMaxHp / 10;
				medal += createScoreObj.remainBlood >= mid ? 3 : createScoreObj.remainBlood >= small ? 2 : 1;
			}
			medal += createScoreObj.timeRemain >= 54 ? 3 : createScoreObj.timeRemain >= 18 ? 2 : 1;
		}
		medal += createScoreObj.gold >= 300 ? 3 : createScoreObj.gold >= 100 ? 2 : 1;
		return medal;
	};

	createScoreObj.getTotalChestMoney = function( )
	{
		var sm = 0;
		if ( createScoreObj.smallChessOpened != null )
		{
			for ( var i = 0; i < createScoreObj.smallChessOpened.size; i++ )
			{
				sm += createScoreObj.smallChessOpened.items[ i ];
			}
		}

		var bm = 0;
		if ( createScoreObj.bigChessOpened != null )
		{
			for ( var i = 0; i < createScoreObj.bigChessOpened.size; i++ )
			{
				bm += createScoreObj.bigChessOpened.items[ i ];
			}
		}

		return sm + bm;
	};

	createScoreObj.getTotalScore = function( )
	{
		var score = 0;
		score += createScoreObj.totalNumberOfGems;
		score += createScoreObj.totalNumberOfCombo;
		score += createScoreObj.remainBlood;
		score += createScoreObj.timeRemain;
		score += createScoreObj.totalNumberOfGoldCollected;
		score += createScoreObj.totalNumberOfDamageDealt;
		return score;
	};

	createScoreObj.reset = function( )
	{
		createScoreObj.totalNumberOfGems = 0;
		createScoreObj.totalNumberOfCombo = 0;
		createScoreObj.remainBlood = 0;
		createScoreObj.timeRemain = 0;
		createScoreObj.totalNumberOfGoldCollected = 0;
		createScoreObj.totalNumberOfDamageDealt = 0;
	};

	return createScoreObj;
};

var battleCalculation = function( invoker, taker, command )
{
	// System.out.println( "calculating command " + command.commandType );
	// he is stun? discard attack
	if ( invoker.isDizzy( ) )
	{
		console.log( 'BattleLogic:battleCalculation: player is dizzy' );
		return;
	}

	var normalized = BattleCommand.normalizeSkillType( command.commandType );
	var rank = BattleCommand.getSkillRank( command.commandType );

	// invoker changing to hp and mp
	var invokerDamage = 0;
	var invokerMpCost = 0;

	// taker changing to hp and mp
	var takerDamage = 0;
	var takerMpCost = 0;

	switch ( normalized )
	{
		case BattleCommand.COMMAND_ATTACK_1:
			if ( rank == 1 )
			{
				invoker.setStatus( true, Character.STATUS_GUARDED );
				break;
			}
			// else if ( rank > 0 )
			// {
			// takerDamage = command.power * invoker.atk1;
			// }
			else if ( rank == 2 )
			{
				takerDamage = 150 - taker.def;
			}
			else if ( rank == 3 )
			{
				takerDamage = 188 - taker.def;
			}
			else
			{
				// invokerMpCost = command.power * BattleLogic.MP_COST_RATE;
				// if ( invoker.mp >= invokerMpCost )
				// {
				// takerDamage = command.power * invoker.atk1 - taker.def;
				// }
				// else
				// {
				// invokerMpCost = 0;
				// }
				if ( command.power == 0 )
				{
					takerDamage = invoker.atk1 * 3 - taker.def;
				}
				else if ( command.power == 1 )
				{
					takerDamage = invoker.atk1 * 6 - taker.def;
				}
				else
				{
					takerDamage = invoker.atk1 * 10 - taker.def;
				}
			}

			// what a pity, atk < def
			if ( takerDamage < 1 )
			{
				takerDamage = 1;
			}
			break;
		case BattleCommand.COMMAND_ATTACK_2:
			if ( rank == 1 )
			{
				invoker.setStatus( true, Character.STATUS_REFLECT );
				break;
			}
			// else if ( rank > 0 )
			// {
			// takerDamage = command.power * invoker.atk2;
			// }
			else if ( rank == 2 )
			{
				takerDamage = 180 - taker.def;
			}
			else if ( rank == 3 )
			{
				takerDamage = 225 - taker.def;
			}
			else
			{
				// invokerMpCost = command.power * BattleLogic.MP_COST_RATE;
				// if ( invoker.mp >= invokerMpCost )
				// {
				// takerDamage = command.power * invoker.atk2 - taker.def;
				// }
				// else
				// {
				// invokerMpCost = 0;
				// }

				takerDamage = invoker.atk2 * 15 - taker.def;
			}

			// what a pity, atk < def
			if ( takerDamage < 1 )
			{
				takerDamage = 1;
			}
			break;
		case BattleCommand.COMMAND_ATTACK_3:
			if ( rank == 1 )
			{
				taker.setStatus( true, Character.STATUS_DIZZY );
				break;
			}
			// else if ( rank > 0 )
			// {
			// takerDamage = command.power * invoker.atk3;
			// }
			else if ( rank == 2 )
			{
				takerDamage = 210 - taker.def;
			}
			else if ( rank == 3 )
			{
				takerDamage = 263 - taker.def;
			}
			else
			{
				// invokerMpCost = command.power * BattleLogic.MP_COST_RATE;
				// if ( invoker.mp >= invokerMpCost )
				// {
				// takerDamage = command.power * invoker.atk3 - taker.def;
				// }
				if ( command.power == 0 )
				{
					takerDamage = invoker.atk3 * 3 - taker.def;
				}
				else if ( command.power == 1 )
				{
					takerDamage = invoker.atk3 * 6 - taker.def;
				}
				else
				{
					takerDamage = invoker.atk3 * 10 - taker.def;
				}
			}

			// what a pity, atk < def
			if ( takerDamage < 1 )
			{
				takerDamage = 1;
			}
			break;
		case BattleCommand.COMMAND_HEAL:
			if ( rank > 0 )
			{
				var hpu = ( invoker.getMaxHp( ) * ( rank * 0.25 ) ) << 0;
				invokerDamage = -hpu;
			}
			else
			{
				invokerDamage = -command.power * BattleLogic.HP_COMBO_FILL_RATE;
			}
			break;
		case BattleCommand.COMMAND_ENERGY_UP:
			// if ( rank > 0 )
			// {
			//  var mpu = ( var ) ( invoker.getMaxMp( ) * ( rank * 0.25f ) );
			// invokerMpCost = -mpu;
			// }
			// else
			// {
			// invokerMpCost = -command.power * BattleLogic.MP_COMBO_FILL_RATE;
			// }
			// break;
		case BattleCommand.COMMAND_MONEY:
		default:
			break;
	}

	// status checking
	// if ( invoker.isGuarded( ) )
	// {
	// if ( invokerDamage > 0 )
	// {
	// invokerDamage >>= 1;
	// }
	// }
	// if ( invoker.isReflect( ) )
	// {
	// if ( invokerDamage > 0 )
	// {
	// takerDamage += invokerDamage >> 1;
	// }
	// }
	if ( taker.isGuarded( ) )
	{
		if ( takerDamage > 0 )
		{
			takerDamage >>= 1;
			// Gdx.app.log( "BattleLogic:battleCalculation()", "Target guarded, damage half" );
		}
	}
	if ( taker.isReflect( ) )
	{
		if ( takerDamage > 0 )
		{
			invokerDamage += takerDamage >> 1;
			// Gdx.app.log( "BattleLogic:battleCalculation()", "Target reflected, damage return" );
		}
	}

	// Gdx.app.log( "BattleLogic:battleCalculation()", "Applying damage" );

	// update total damage dealt
	if ( invokerDamage > 0 )
	{
		taker.addTotalDamageDealt( invokerDamage );
	}

	if ( takerDamage > 0 )
	{
		invoker.addTotalDamageDealt( takerDamage );
	}

	invoker.hp -= invokerDamage;
	invoker.mp -= invokerMpCost;
	invoker.trim( );

	taker.hp -= takerDamage;
	taker.mp -= takerMpCost;
	taker.trim( );

	// System.out.println( "invoker " + invokerDamage + " " + invokerMpCost );
	// System.out.println( "taker " + takerDamage + " " + takerMpCost );
}

// BattleLogicEvent:
//	public boolean notifyListener( BattleCommand battleCommand );
var createBattleLogic = exports.createBattleLogic = function( battleModel, logicEvents )
{
	var createBattleLogicObj = {};
	createBattleLogicObj.battleModel = battleModel;
	createBattleLogicObj.battleLogicEvents = logicEvents;
	createBattleLogicObj.gameOver	= false;
	createBattleLogicObj.command = function( command )
	{
		if ( command.playerId == BattleCommand.PLAYER_1 )
		{
			// Gdx.app.log( "BattleLogic:process()", "Calculate player 1" );
			battleCalculation( createBattleLogicObj.battleModel.character1, createBattleLogicObj.battleModel.character2, command );
		}
		else if ( command.playerId == BattleCommand.PLAYER_2 )
		{
			// Gdx.app.log( "BattleLogic:process()", "Calculate player 2" );
			battleCalculation( createBattleLogicObj.battleModel.character2, createBattleLogicObj.battleModel.character1, command );
		}
		else
		{
			console.log( 'BattleLogic:command(): unknown player ' + command.playerId );
		}

		if ( createBattleLogicObj.battleLogicEvents != null )
		{
			createBattleLogicObj.battleLogicEvents.notifyListener( command );

			var player1die = createBattleLogicObj.battleModel.character1.hp <= 0;
			var player2die = createBattleLogicObj.battleModel.character2.hp <= 0;
			if ( player1die || player2die )
			{
				createBattleLogicObj.gameOver = true;
				var bc = createBattleCommand();
				bc.commandType = BattleCommand.COMMAND_KO;
				bc.playerId = player1die && player2die ? BattleCommand.PLAYER_ZERO
						: player1die ? BattleCommand.PLAYER_2 : BattleCommand.PLAYER_1;
				createBattleLogicObj.battleLogicEvents.notifyListener( bc );

				// Gdx.app.log( "BattleLogic:command()",
				// "Player 1 total damage dealt " + battleModel.character1.getTotalDamageDealt( ) );
				// Gdx.app.log( "BattleLogic:command()",
				// "Player 2 total damage dealt " + battleModel.character2.getTotalDamageDealt( ) );
				// freed in battleLogicEventFilter
				// BattleCommand.free( bc );

				// System.err.println( "In battle logic KO" );
				// Thread.dumpStack( );
			}
		}
	};

	createBattleLogicObj.getBattleModel = function( )
	{
		return battleModel;
	};

	createBattleLogicObj.newGame = function( )
	{
		createBattleLogicObj.gameOver = false;
		if ( createBattleLogicObj.battleLogicEvents != null )
		{
			var command = createBattleCommand( );
			command.commandType = BattleCommand.COMMAND_NEW_GAME;
			createBattleLogicObj.battleLogicEvents.notifyListener( command );
		}
	}

	createBattleLogicObj.battleLogicProcess = function( )
	{
		if ( createBattleLogicObj.gameOver )
		{
			return;
		}

		createBattleLogicObj.battleModel.battleModelProcess( );
	};


	createBattleLogicObj.setBattleLogicEvent = function( battleLogicEvent )
	{
		createBattleLogicObj.battleLogicEvents = battleLogicEvent;
	}

	createBattleLogicObj.suicide = function( playerId )
	{
		// TODO Auto-generated method stub
		if ( playerId == BattleCommand.PLAYER_1 )
		{
			createBattleLogicObj.battleModel.character1.hp = 0;
		}
		else if ( playerId == BattleCommand.PLAYER_2 )
		{
			createBattleLogicObj.battleModel.character2.hp = 0;
		}

		if ( createBattleLogicObj.battleLogicEvents != null )
		{
			var player1die = createBattleLogicObj.battleModel.character1.hp <= 0;
			var player2die = createBattleLogicObj.battleModel.character2.hp <= 0;
			if ( player1die || player2die )
			{
				createBattleLogicObj.gameOver = true;
				var bc = createBattleCommand( );
				bc.commandType = BattleCommand.COMMAND_KO;
				bc.playerId = player1die && player2die ? BattleCommand.PLAYER_ZERO
						: player1die ? BattleCommand.PLAYER_2 : BattleCommand.PLAYER_1;
				createBattleLogicObj.battleLogicEvents.notifyListener( bc );

				console.log( "BattleLogic:suicide()",
						"Player 1 total damage dealt " + createBattleLogicObj.battleModel.character1.getTotalDamageDealt( ) );
				console.log( "BattleLogic:suicide()",
						"Player 2 total damage dealt " + createBattleLogicObj.battleModel.character2.getTotalDamageDealt( ) );
			}
		}
	}

	return createBattleLogicObj;
};